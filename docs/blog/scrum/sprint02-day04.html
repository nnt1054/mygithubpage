<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="google" content="notranslate" />

  <title>Neil Toledo - Sprint #2 - Daily Scrum #04</title>
  <meta name="description" content="Product: Tetris2P AISprint Summary">

  <link rel="icon" href="/assets/images/me.jpg">
  <link rel="shortcut icon" href="/assets/images/me.jpg">
  <link rel="apple-touch-icon" href="/assets/images/me.jpg">

  <link rel="stylesheet" href="/assets/css/rouge.css">
  <link rel="stylesheet" href="/assets/css/main.css">
  <link href='https://fonts.googleapis.com/css?family=Comfortaa' rel='stylesheet'>
</head>

  <body>
    <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Sprint #2 - Daily Scrum #04</h1>
    <p class="post-meta"><time datetime="2019-07-18T00:00:00-07:00" itemprop="datePublished">Jul 18, 2019</time></p>
  </header>

  <link rel="stylesheet" href="/assets/css/posts.css">
  <a id="back-id" class="rect-btn center-container height32 back-btn" href=/blog/scrum> <span>&#8592Back</span> </a>

  <div class="post-content" itemprop="articleBody">
    <p><b>Product:</b> Tetris2P AI<br />
<a href="/blog/projects/tetris-ai-sprint-2">Sprint Summary</a></p>

<h4 id="daily-objectives">Daily Objectives</h4>
<ul>
  <li>Figure out game structure and create main menu scenee</li>
</ul>

<h4 id="notes">Notes</h4>

<p class="column">First things first, lets draw a mockup or the game client
<img src="/assets/scrum/sprint2day4image1.png" alt="client server" class="column post-image" /></p>

<p>What VIew’s/Game Modes/Screens do we need (in the context of adding buttons to the screen/UI)
* Sprint Mode
* VS Random Opponent
* VS AI
* Create Lobby(?)
* Join Lobby
* Settings</p>

<p>THIS IS IMPORTANT UI WORK OK; Main Menu Buttons:
* Marathon/Practice
	* Secondary game menu(?)
		* restart 
		* Exit to main menu
		* Play AI
		* settings
	* Quickplay
		* Random matchmaking
		* Eventually can include account and mmr if i wanted to
			* Save mmr using cookies or something
	* Create Lobby
		* join lobby using url
	* Settings
		* controls/speed/ui customization/etc
		* control global setting variables</p>

<p>UI SHOULD NOT BE AN ISSUE RN
* Issue is having similar menus for different UI’s
* I’m really into Top-Down approach apparently</p>

<p>Ok we’re going to uh:
* During gameplay always show the two tetris ‘instances’
* Leave second one blank, if single player mode
* If lobby and no second player yet:
	* Display invite code on empty tetris instance
* In lobby with second player:
	* Display name on second tetris instance, also maybe ready status
* In lobby:
	* Ready Up button/status
	* Spectate or Join game button
* During Game/In Lobby: Press ESCAPE to show menu:
	* Leave to Main Menu Button
	* Settings button or button settings</p>

<p>OK ENOUGH WITH THE HECKING UI AND BUTTON WORK:
Let’s talk game and game Pieces
* Tetris Game Instance (2x)
	* Held Piece
	* Piece Queue
		* Will be moved to match instance object instead later
	* Game Grid
	* Current Tetriminos
	* Lines Sent
	* KO’s
	* Game Timer
* Tetrominos (parent class for all tetrominos, make subclass for each type)
	* Anchor Position
	* Tetromino Type/Shape
	* Current Orientation
	* Orientation Number
	* Orientation Dictionary
* Tetris Match Instance
	* Tetris Game Instance (2x)
	* Piece Queue
		* This is to make sure both instances have the same queues
	* Match Timer</p>

<p>So App Instance &gt; Tetris Match Instance &gt; Tetris Game Instance &gt; Tetrimono Instance
Game Instance update function (delta passed as parameter):
* Check if time to drop piece in this update
	* If piece, can’t drop further:
		* Lock piece to stack
		* UpdateGameState() // defined below
		* break()
* If update function continues:
	* Process input(s):
		* need to check for short presses and long presses
		* Perform action on short press
		* Perform long press action on set intervals
			* Applies to both rotating and moving pieces
	* If hold piece:
		* Update held tetromino piece
		* spawnNewTetromino()</p>

<p>UpdateGameState() //occurs after a piece is locked
* Update cells in game grid based on locked piece
* If line cleared:
	* Clear row(s) in grid
	* Shift other rows downward
	* Calculate combo streak
* If no line cleared:
	* Add Trash Lines
	* Check if ToppedOut
		* Either EndGame() or addKO(), removeTrash()
* spawnNewTetromino():
	* If unable to:
		* Either EndGame() or addKO(), removeTrash()</p>

<p>oh HECK how do you do animations with html5 canvas<br />
Should I process input first or not; probably do drop first<br />
Uh make sure to remember, to check game stuff based on the Match Timer and not a time elapsed function<br />
Make general purpose function for checking if a piece is touching a floor
* Can use same function for creating ghost<br />
Only need to check game state when game state changes:<br />
* GameState only changes when a piece is dropped
* Trash Lines will only appear if a piece has dropped
Incorporate ‘Scenes’ and ‘GameStates’
* Scenes:
	* MainMenu
heck im already stressed again
Create separate files for scenes and objects
* MainMenuScene
* SinglePlayerScene
* LobbyScene
Main.js starts the actual game, creates the actual game and canvas
* Main.js handles the update loop and is the object for the actual game/screen
* Main.js handles switching between Scene Objects
* Main.js handles all the global variables and settings
* MAIN.JS IS THE GAME CLIENT</p>

<h4 id="objectives-completed">Objectives Completed</h4>

<ul>
  <li>
    <p>Mapped out the game navigation and corresponding buttons for each scene</p>
  </li>
  <li>
    <p>Fleshed out necessary gameObjects again</p>
  </li>
  <li>
    <p>Created and detailed pseudocode for the actual game logic</p>
  </li>
</ul>

  </div>

</article>
  </body>


  <script src="/assets/js/jquery-3.3.1.min.js"></script>
  <script src="/assets/js/main.js"></script>
  <link rel="stylesheet" href="/assets/css/mobile.css">
</html>